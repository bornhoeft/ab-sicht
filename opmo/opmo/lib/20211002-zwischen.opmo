;;; ---------------------------------------------------------
;;; Sicht
;;; Copyright © 2015-2021 Achim Bornhoeft
;;;
;;; zwischen
;;;
;;; ---------------------------------------------------------

(load (merge-pathnames "../lisp/functions.lisp" *load-truename*))

(defparameter *do-verbose* nil
  "Enable or disable traces printed by do-verbose.")

;;; Pitches

(defparameter listed-ratios
(loop for i from 2 to 7
  collect
    (loop 
      with x =  (* 3 i)
      for k from x to (* x 2)     
      collect  (* 1.0 (/ k i)))))

(defparameter sorted-ratios
  (loop for i in listed-ratios
    for x from 1
    if (oddp x)
    collect i 
    else
    collect (cdr (butlast (reverse i))))) 

(defparameter ratios 
  (succ-shuffle (flatten sorted-ratios) 30 :seed 123) ; see functions.lisp
  "Flattened list of ratios with some successive values randomly shuffled.")

#|
;; (fl ratios) = 81  

(let ((mcr ratios))
  (list  (* 1.0 (find-min mcr)) (* 1.0 (find-max mcr))))
;; => min/max factors: (3.0 6.0)
  
(loop for i in listed-ratios collect (length i))
;; => increasing length of waves: (7 10 13 16 19 22)
|#

(defparameter diff (pitch-to-hertz 'g2)
  "fixed difference tone")

(defparameter diff-tones
  (loop for i in ratios 
             collect
             (comb-fix-tones diff (* diff i) 1 3)))

(defparameter pitches
  (matrix-transpose
   (quarter-tone-closest
    (hertz-to-pitch
     diff-tones
     :quantize 1/4)))
  "Quantize pitches to quartertones and convert chords to voices.") 

(defparameter numb-pitches (length (first pitches))
  "number of pitches per voice")

(defparameter numb-inst (length (first diff-tones))
  "number of instruments (voices)")

;;; Voices Percussion & Piano

(defparameter combtones-chords-pp
  (loop for i in
 (comb-tones freq1 (flatten trans-ratios) 2 6 :ratios t :chords t)
  collect
  (loop for j in i 
    when (> j 0) collect j)))

(defparameter pp-voices
  (make-omn
   :pitch (chordize
           (midi-to-pitch
            (loop for i in
              (pitch-to-midi
               (hertz-to-pitch combtones-chords-pp :quantize 1/4))
              collect
              (remove-duplicates
              (loop for j in i
                when (integerp j)
                collect j)))))
   :length '(w) ; '(q -h.)
   :span :pitch))

(defparameter pno-rh
  (ambitus-filter '(c4 a7) pp-voices))

(defparameter pno-lh
  (ambitus-filter '(a0 b3) pp-voices))

(defparameter glsp
  (ambitus-filter '(g6 c8)  pp-voices))

(defparameter vibr
  (ambitus-filter (integer-to-pitch (ambitus-instrument 'vibraphone)) pp-voices))

(defparameter timp
  (ambitus-filter '(d2 g2) pp-voices))

;;; Durations

(defparameter parts (sum-to-size numb-pitches 3)
  "Number of events divided in 3 possible equal numbers for 3 parts")

(defparameter counts
  (loop repeat numb-inst
    initially (init-seed 123)
    collect
  (loop for i in parts
    collect
  (rnd-sum i '(2 3 4 5))))
  "4 counts randomly chosen fitting the overall number of events")

;; durations +/- 3/4

;; Count 5
(defparameter dur3-5 
  (dev-durations 3/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur3-4 
 (mapcar #'cdr dur3-5)
  "only the deviations.")

;; Count 3
(defparameter dur3-3-1 
  (dev-durations 3/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur3-3-2 
  (dev-durations 3/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur3-2-1 
  (mapcar #'cdr dur3-3-1)
  "only the deviations")

(defparameter dur3-2-2 
  (mapcar #'cdr dur3-3-2)
  "only the deviations")

;; durations +/- 4/4

;; Count 5
(defparameter dur4-5 
  (dev-durations 4/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur4-4 
 (mapcar #'cdr dur4-5)
  "only the deviations.")

;; Count 3
(defparameter dur4-3-1
  (dev-durations 4/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur4-3-2 
  (dev-durations 4/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur4-2-1 
  (mapcar #'cdr dur4-3-1)
  "only the deviations")

(defparameter dur4-2-2 
  (mapcar #'cdr dur4-3-2)
  "only the deviations")

;; durations +/- 5/4

;; Count 5
(defparameter dur5-5 
  (dev-durations 5/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur5-4 
 (mapcar #'cdr dur5-5)
  "only the deviations.")

;; Count 3
(defparameter dur5-3-1
  (dev-durations 5/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur5-3-2 
  (dev-durations 5/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur5-2-1 
  (mapcar #'cdr dur5-3-1)
  "only the deviations")

(defparameter dur5-2-2 
  (mapcar #'cdr dur5-3-2)
  "only the deviations")

(defparameter dur-lists
  (loop for i in counts
    initially (init-seed 123)
    collect
    (loop for j in i
      for k from 0
      collect
      (rnd-order
       (loop for l in j
         when (= k 0) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur4-2-1 dur4-2-2))))
           (3 (rnd-order (rnd-pick (append dur4-3-1 dur4-3-2))))
           (4 (rnd-order (rnd-pick dur4-4)))
           (5 (rnd-order (rnd-pick dur4-5))))
         when (= k 1) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur3-2-1 dur3-2-2))))
           (3 (rnd-order (rnd-pick (append dur3-3-1 dur3-3-2))))
           (4 (rnd-order (rnd-pick dur3-4)))
           (5 (rnd-order (rnd-pick dur3-5))))
         when (= k 2) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur5-2-1 dur5-2-2))))
           (3 (rnd-order (rnd-pick (append dur5-3-1 dur5-3-2))))
           (4 (rnd-order (rnd-pick dur5-4)))
           (5 (rnd-order (rnd-pick dur5-5)))))))))

#|
(loop for i in dur-lists
  collect (find-sum (flatten i)))
|#

(defparameter durations (quantize (mcflatten dur-lists) '(1 2 3 4 5 6)))

(defparameter time-sig
  (loop for i in parts
    for j in '(4 3 5)
    collect (list j 4 i)))

;;; Dynamics

(defparameter vel-f1
    (flatten
     (loop for j in (first durs)     
       for k from 0 collect
       (if (evenp k)
         (loop repeat (- (length j) 1)
           collect '< into reslis
           finally (return (cons 'pp< reslis)))
         (loop repeat (- (length j) 1)
           collect '> into reslis
           finally (return (cons 'p> reslis )))))))

(defparameter vels
  (loop repeat 7
    initially (init-seed 25)
    collect
    (velocity-to-dynamic
     (gen-weight numb-pitches '((ppp 20) (pp 20)(p 20)(mf 20) (f 20))))))

(defparameter dummy-vels
  (cons 'ppp (cdr (loop repeat numb-pitches collect '-))))

(defparameter velocities
  (list
   (first vels)
   (second vels)  
   (third vels)
   (fourth vels)
   dummy-vels
   vel-f1
   (sixth vels)
   (seventh vels)))

;;; Articulations
;;; (list of possible articulations see User Attributes.lisp)

;;; Glissandi

(defparameter gliss-prob-env
  ;; (xy-plot
  (pair-up
   (envelope-exp 
    '(0 0 1 0 3 3 5 6 8 10 11 20 13 10 16 0) 
    1.2 (- numb-pitches 1))))
   ;;:join-points t :point-radius 2 :style :axis))

;; (length gliss-prob-env)

(defparameter gliss-prob
  (mapcar #'round
          (second
           (matrix-transpose
            gliss-prob-env)))
  "Extracting and rounding probabilities from env.")
           
(defparameter glissandi
  (mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
     (loop for i in gliss-prob    
       collect
       (gen-weight 1 (list (list 'gliss i) (list '- 10)))))))

;; (ll glissandi)

;; Test
#!
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length glissandi)
                     (list (gen-repeat (length (first glissandi)) 'w)))
            :pitch '((b4))
            :articulation glissandi)
    :time-signature '(4 4))
!#

;;; Tremolos

(defparameter trem-prob-envs
  '((0 10 10  0  0  0  0  0) ; trem-t+trt = 1/32 = 8
    (0  0 20 10  0  0  0  0) ; trem-5e+tr5e = 1/40 = 10
    (0  0  0 30 20 10  0  0) ; trem-3s+tr3s = 1/48 = 12
    (0  0  0 40 30 20 10  0) ; trem-7e+tr7e = 1/56 = 14
    (0  0  0  0 50 30 20 10) ; trem-x+trx = 1/64 = 16
    (100 100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-trem-probs
  (loop for i in trem-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter trem-probs
  (loop for i in xy-trem-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter trem-types
  '(trem-t+trt
    trem-5e+tr5e
    trem-3e+tr3s
    trem-7e+tr7e
    trem-x+trx
    -)
  "List of articulations.")

(defparameter trem-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in trem-probs 
    for k in trem-types
    collect
    (loop for j in i
      collect (list k j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter tremolos
(mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
  (loop for i in trem-prob-lists
  collect
  (gen-weight 1 i)))))

;;(ll tremolos)

;; Test
#!
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length tremolos)
                     (list (gen-repeat (length (first tremolos)) 'w)))
            :pitch '((b4))
            :articulation tremolos)
    :time-signature '(4 4))
!#

;;; blow (woods)

(defparameter blow-prob-envs
  '((0 10 10  0  0  0  0) ; tone start
    (0  0 20 10  0  0  0) ; half-start
    (0  0  5 20 30 10  0) ; air-start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-blow-probs
  (loop for i in blow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter blow-probs
  (loop for i in xy-blow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter blow-types
  '((tone-air-tone ; ●⟹○⟹●
     tone-air-half ; ●⟹○⟹◐
     tone-half-tone ; ●⟹⌀⟹●
     tone-air ; ●⟹○
     )
    (half-tone-half ; ⌀⟹●⟹⌀
     half-tone-air ; ⌀⟹●⟹○
     half-air-half ; ⌀⟹○⟹⌀
     half-air-tone ; ⌀⟹○⟹●
     )
    (air-tone-air ; ○⟹●⟹○
     air-tone-half ; ○⟹●⟹⌀
     air-half-air ; ○⟹⌀⟹○
     air-tone ; ○⟹●
     )
    -)
  "List of sound articulations.")

(defparameter blow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in blow-probs 
    for k in blow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter blows
(mcflatten
   (loop repeat 4
     initially (init-seed 123)
     collect
  (loop for i in blow-prob-lists
  collect
  (gen-weight 1 i)))))

;;; bows (strings)

(defparameter bow-prob-envs
  '((0 10 10  0  0  0  0) ; tasto start
    (0  0 20 10  0  0  0) ; ord start
    (0  0  5 20 30 10  0) ; pont start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-bow-probs
  (loop for i in bow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the bowing probabilities.")

(defparameter bow-probs
  (loop for i in xy-bow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter bow-types
  '((t-o ; t⟹o
     t-p ; t⟹p
     t-o-t ; t⟹o⟹t
     t-p-o ; t⟹p⟹o
     t-p-t ; t⟹p⟹t
     )   
    (o-p ; o⟹p
     o-t ; o⟹t
     o-t-o ; o⟹t⟹o
     o-p-o ; o⟹p⟹o
     o-t-p ; o⟹t⟹p
     o-p-t ; o⟹p⟹t
     )
    (p-o ; p⟹o
     p-t ; p⟹t
     p-o-p ; p⟹o⟹p
     p-t-o ; p⟹t⟹o
     p-t-p ; p⟹t⟹p
     )
    -)
  "List of sound articulations.")

(defparameter bow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in bow-probs 
    for k in bow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter bows
(mcflatten
   (loop repeat 4
     initially (init-seed 579)
     collect
  (loop for i in bow-prob-lists
  collect
  (gen-weight 1 i))))
  "bow articulations")

(defparameter var-tones
  (assign-variable 'tones (append blows bows))
  "combine blow (woods) and bow (strings) atriculations into variables")

(defparameter tones
  (reverse (list tones0 tones1 tones4 tones2 tones3 tones5 tones6 tones7))
  "sort tone variables according to the voices: fl cl vc2 ob tsax va vn (vc1).
  Reversed because the voices are reversed in make-omn!!!")

;; Test
#!
(ps 'gm    
    :multi
    (make-omn
     :length (gen-repeat
              (length var-tones)
              (list (gen-repeat (length (eval (first var-tones))) 'w)))
     :pitch '((b4))
     :articulation (mapcar #'eval var-tones))
    :time-signature '(4 4))
!#

;;; Vibrato

(defparameter vib-prob-envs
  '(( 0 20 30 20 15 10  5) ; vibs
    (30 30 30 30 30 30 30) ; -
    )
  "general developement of weighted probabilities")

(defparameter xy-vib-probs
  (loop for i in vib-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter vib-probs
  (loop for i in xy-vib-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the envelope xy-vib-probs
             ))))

(defparameter vib-art
  '(non-vib ; non-vib  
    nv-v-nv ; non vib⟹vib⟹non vib
    v-nv ; v⟹nv 
    v-mv-nv ; v⟹mv⟹nv 
    nv-v ; nv⟹v
    nv-mv-nv ; nv⟹mv⟹nv
    v-nv-v ; v⟹nv⟹v
    nv-mv-v ; nv⟹mv⟹v  
    mv-nv-v ; mv⟹nv⟹v
    mv-nv ; mv⟹nv  
    v-mv-v ; v⟹mv⟹v
    mv-v ; mv⟹v
    nv-mv ; nv⟹mv
    v-mv ; v⟹mv
    v-nv-mv ; v⟹nv⟹mv 
    mv-v-mv ; mv⟹v⟹mv
    mv-nv-mv ; mv⟹nv⟹mv
    )
  "List of 17 vibrato articulations, sorted from less to more")

(defparameter vib-articulations
  (gen-palindrome vib-art)
  "Palindrome of the vib-articulations, 33 vibratos: less ⟹ more ⟹ less."
  )

(defparameter vib-ids
  (let* ((len-vib-art (- (length vib-articulations) 1))
         (tend-ids (mapcar #'round 
                           (gen-tendency numb-pitches (list 0.1 len-vib-art) 
                                         :variance 0.5 :seed 123))))
    (loop for i in tend-ids collect (min i len-vib-art)))
  "Tendency of IDs from start to end in the vib-articulations list."
  )

(defparameter vib-art-probs
  (matrix-transpose 
   ; combine probability list of all articulations at each point
  (loop for i in vib-probs
    for x from 0
    collect
    (loop for j in i
      for y from 0
      when (= x 0)
      collect (list (nth (nth y vib-ids) vib-articulations) j)
      ; combine the probabilities with the according articulation
      when (= x 1)
      collect (list '- j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter weighted-vibs
  (loop repeat numb-inst
    initially (init-seed 73)
    collect
    (flatten
     (loop for i in vib-art-probs   
       collect
       (gen-weight 1 i)))))

(defparameter vibratos
(loop for i in weighted-vibs
  collect (position-replace '(0) '(non-vib) i)))

#!
;; Test
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length vibratos)
                     (list (gen-repeat (length (first vibratos)) 'w)))
            :pitch '((b4))
            :articulation vibratos)
    :time-signature '(4 4))
!#

;;; Merge Attributes

(defparameter merged-articulations
  (merge-attributes glissandi tremolos tones vibratos)
  "merge all articulations for each voice")

;; (ll merged-articulations)

(defparameter dummy-articulations
  (cons 'arrow (cdr (loop repeat numb-pitches collect '-)))
  "Make a dummy articulation list for the upper voice of the viola
  with an arrow at the beginning (to be manually DELETED LATER).")

(defparameter articulations
  (list-replace-at merged-articulations 0 (list dummy-articulations))
  "Replace the articulation list of the upper voice of the violoncello
  with the dummy articulation list.")
 
;;; Voices
    
(defparameter omn
  (reverse
  (make-omn
   :pitch pitches
   :length durations
   :velocity velocities
   :articulation articulations))
  "Create omn voices.")

(defparameter voices (assign-variable 'voice omn)
  "assign variable for each voice")

;;; Score

#!
;; Preview
(ps 'gm
    :multi voices
    :time-signature time-sig
    :tempo 60)
!#

(def-score zwischen
           (
            :key-signature 'chromatic
            :time-signature time-sig
            :tempo 60
            :layout (list
                     (bracket-group
                      (flute-layout 'fl)
                      (oboe-layout 'ob)
                      (clarinet-layout 'cl)
                      (tenor-sax-layout 'tsax))
                     (bracket-group
                      (glockenspiel-layout 'glsp)
                      (vibraphone-single-layout 'vibr)
                      (timpani-layout 'timp))
                     (piano-layout 'piano-rh 'piano-lh)
                     (bracket-group
                      (violin-layout 'vn)
                      (viola-solo-layout 'va)
                      (violoncello-solo-layout (list 'vc1 'vc2))))
            )
  (fl :omn voice0 :channel 1 :sound 'gm :program 'flute) 
  (ob :omn voice3 :channel 2 :program 'oboe)
  (cl :omn voice1 :channel 3 :program 'clarinet)
  (tsax :omn voice4 :channel 4 :program 'tenor-sax)
  (glsp :omn glsp :channel 5 :program 'glockenspiel)
  (vibr :omn vibr :channel 6 :program 'vibraphone)
  (timp :omn timp :channel 7 :program 'timpani)
  (piano-rh :omn pno-rh :channel 8 :program 'grand)
  (piano-lh :omn pno-lh :channel 9 :program 'grand)
  (vn :omn voice6 :channel 10 :program 'violin)
  (va :omn voice5 :channel 11 ::program 'viola)
  (vc1 :omn voice7 :channel 12 ::program 'cello)
  (vc2 :omn voice2 :channel 13 :program 'cello)
  )

(let* ((dursec (* 4.0
                  (get-span (first dur-lists) :sum t)))
       (minutes (floor (/ dursec 60)))
       (seconds (- dursec (* minutes 60))))                
  (format t "Duration: ~F min ~F sec " minutes seconds))

#!
(with-open-file 
    (file "~/Documents/projekte/03-kammermusik5-9/AB93-Plain/opmo/xml/zwischen.xml" 
          :direction :output 
          :if-exists :supersede)
  (score-to-musicxml (get-score 'zwischen) file))

(pprint-score 'zwischen)
!#