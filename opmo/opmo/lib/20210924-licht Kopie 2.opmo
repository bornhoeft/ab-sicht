;;; ---------------------------------------------------------
;;; Sicht
;;; Copyright © 2015-2021 Achim Bornhoeft
;;;
;;; licht
;;;
;;; ---------------------------------------------------------

(load (merge-pathnames "../lisp/functions.lisp" *load-truename*))

(defparameter *do-verbose* nil
  "Enable or disable traces printed by do-verbose.")

;;; Pitches

;;; TODO: transitions, reduce to 5 min, reduce lower wave ambitus

(defparameter listed-ratios
  (loop for i from 12 to 24
    ; number of steps depending on limits below
    collect
    (if (oddp i)           
      (loop for j from i to (* 2 i)
        ; odd IDs increasing ratios
        for k = (/ j i)
        when (and (>= k 6/4) (<= k 7/4))
        collect k)
      (loop for j from (* 2 i) downto i
        ; even IDs decreasing ratios
        for k = (/ j i)
        when (and (>= k 6/4) (<= k 7/4))
        collect k))) 
  
  "Ratios = Intervals between f2 and f1.
  All ratios between 1.5 and 1.75, odd denominator increasing 
  and even denominator decreasing: form with tendencially 
  increasing length of waves: 3 to 7 steps.")

(defparameter ratios 
  (succ-shuffle (flatten listed-ratios) 20 :seed 123) ; see functions.lisp
  "Flattened list of ratios with some successive values randomly shuffled.")

#|
(let ((mcr ratios))
  (list  (* 1.0 (find-min mcr)) (* 1.0 (find-max mcr))))
;; => min/max ratios: (1.5 1.75)
  
(loop for i in listed-ratios collect (length i))
;; => tendencially increasing length of waves: (4 3 4 4 5 4 5 5 6 5 6 6 7)
|#

(defparameter numb-trans
  (gen-transition 3 2 (length ratios) 1 :rounded t)
  "List of transitions for all ratios.") 

(defparameter trans-ratios
  (loop for x in numb-trans
  with l = ratios
  for i in l ; first value
  for j in (cdr l) ; second value
  collect (cdr (gen-transition i j x 1)) into reslis
    ; cut off the first value = the last of the previous one
  finally (return (append 
                   (list (cons (first l) (first reslis)))
                   ; add the first value to the first list
                   (cdr reslis)
                   ; and append it to the rest of the results
                   )))
  "Ratios: = Intervals between f2 and f1.
  Inserted transitions between each value in ratios.
  Balance the waves with transitions from 3 to 2")
  
(defparameter freq1 (pitch-to-hertz 'd4)
  "Fixed f1 frequency")

(defparameter combtones-chords
 (comb-tones freq1 (flatten trans-ratios) 2 3 :ratios t :chords t) 
  "Combination tones for f1 and each ratio as list of freqs
  (see functions.lisp)")

#|
;; combtones as chords
(length
(flatten
(chordize
(hertz-to-pitch
 combtones-chords :quantize 1/4))))

;; check which pitch is f2
(pitch-list-plot 
 (hertz-to-pitch (comb-tones freq1 ratios 1 1 :ratios t))
 :join-chords t :join-points t)

(setf freq1 (pitch-to-hertz 'd4))

(pitch-list-plot 
 (hertz-to-pitch
  (list (list freq1 freq1) (list (* 6/4 freq1) (* 7/4 freq1)))) 
 :join-points t :join-chords nil)
|#

(defparameter pitches
  (reverse
   (mapcar #'quarter-tone-closest ; see functions.lisp
           (hertz-to-pitch
            (sort
             (matrix-transpose combtones-chords)       
             '< :key 'first) 
            :quantize 1/4)))
  "
  1. convert the list of combination tones to voices
  2. sort them from low to high
  3. convert from frequency to pitch
  4. Convert pitches with 3 to 1 quartertone alteration 
  5. reverse these lists according to the score")

#|
(flatten (chordize (matrix-transpose pitches)))

(ll pitches)
|#

;;(pitch-list-plot pitches :join-chords t :join-points t)

(defparameter numb-pitches (length combtones-chords)
  "number of pitches per voice")

(defparameter numb-inst (length pitches)
  "number of instruments (voices)")

;;; Durations

(defparameter dur3 '((3/4)))
(defparameter dur4 '((4/4)))
(defparameter dur5 '((5/4)))

(defparameter dur9 
  (dev-durations 3/4 '(16 20) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur6 
  (mapcar #'cdr (dev-durations 3/4 '(16 20) '(-1 1) :flat nil))
  "only the deviations of 3/4, (see functions.lisp)")

(defparameter dur12 
  (dev-durations 4/4 '(12 16 20) '(-1 1) :flat nil)
  "4/4 duration with 3 deviations, (see functions.lisp)")

(defparameter dur8 
  (mapcar #'cdr (dev-durations 4/4 '(12 16 20) '(-1 1) :flat nil))
  "only the deviations of 4/4, (see functions.lisp)")

(defparameter dur15 
  (dev-durations 5/4 '(10 12 16 20) '(-1 1) :flat nil)
  "5/4 duration with 4 deviations, (see functions.lisp)")

(defparameter dur10 
  (mapcar #'cdr (dev-durations 5/4 '(10 12 16 20) '(-1 1) :flat nil))
  "only the deviations of 5/4")

(defparameter measures
  (rnd-sum numb-pitches '(1 2 3) :seed 12)
  "3 durs randomly chosen fitting the overall number of pitches")

(defparameter durs
(matrix-transpose
 (loop for i in measures
   initially (init-seed 13)
   with *do-verbose* = nil
   ; starting counter for all random choices
   for x = (case i
             (1 (rnd-pick (append dur3 dur4 dur5)))
             (2 (rnd-pick (append dur6 dur8 dur10)))
             (3 (rnd-pick (append dur9 dur12 dur15))))
   collect (loop repeat numb-inst
     collect (rnd-order x))))
  "durations in blocks between dur3 and dur15")

(defparameter durations (mcflatten durs))

(defparameter time-sig
  (get-time-signature
   (mclist
    (flatten
     (loop for i in (first durs) 
       for j = (length i) 
       collect
       (loop repeat j collect (/ (sum i) j))))))  
  "get the time signature from the first voice")

;;; Dynamics

(defparameter vel-f1
    (flatten
     (loop for j in (first durs)     
       for k from 0 collect
       (if (evenp k)
         (loop repeat (- (length j) 1)
           collect '< into reslis
           finally (return (cons 'pp< reslis)))
         (loop repeat (- (length j) 1)
           collect '> into reslis
           finally (return (cons 'p> reslis )))))))

(defparameter vels
  (loop repeat 7
    initially (init-seed 25)
    collect
    (velocity-to-dynamic
     (gen-weight numb-pitches '((ppp 40) (pp 30)(p 20)(mf 10))))))

(defparameter dummy-vels
  (cons 'ppp (cdr (loop repeat numb-pitches collect '-))))

(defparameter velocities
  (list
   (first vels)
   (second vels)  
   (third vels)
   (fourth vels)
   dummy-vels
   vel-f1
   (sixth vels)
   (seventh vels)))

;;; Articulations
;;; (list of possible articulations see User Attributes.lisp)

;;; Glissandi

(defparameter gliss-prob-env
  ;; (xy-plot
  (pair-up
   (envelope-exp 
    '(0 0 1 0 3 3 5 6 8 10 11 20 13 10 16 0) 
    1.2 (- numb-pitches 1))))
   ;;:join-points t :point-radius 2 :style :axis))

;; (length gliss-prob-env)

(defparameter gliss-prob
  (mapcar #'round
          (second
           (matrix-transpose
            gliss-prob-env)))
  "Extracting and rounding probabilities from env.")
           
(defparameter glissandi
  (mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
     (loop for i in gliss-prob    
       collect
       (gen-weight 1 (list (list 'gliss i) (list '- 10)))))))

;; (ll glissandi)

;;; Tremolos

(defparameter trem-prob-envs
  '((0 10 10  0  0  0  0  0) ; trem-t+trt = 1/32 = 8
    (0  0 20 10  0  0  0  0) ; trem-5e+tr5e = 1/40 = 10
    (0  0  0 30 20 10  0  0) ; trem-3s+tr3s = 1/48 = 12
    (0  0  0 40 30 20 10  0) ; trem-7e+tr7e = 1/56 = 14
    (0  0  0  0 50 30 20 10) ; trem-x+trx = 1/64 = 16
    (100 100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-trem-probs
  (loop for i in trem-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter trem-probs
  (loop for i in xy-trem-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter trem-types
  '(trem-t+trt
    trem-5e+tr5e
    trem-3e+tr3s
    trem-7e+tr7e
    trem-x+trx
    -)
  "List of articulations.")

(defparameter trem-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in trem-probs 
    for k in trem-types
    collect
    (loop for j in i
      collect (list k j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter tremolos
(mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
  (loop for i in trem-prob-lists
  collect
  (gen-weight 1 i)))))

;;(ll tremolos)

;;; blow (woods)

(defparameter blow-prob-envs
  '((0 10 10  0  0  0  0) ; tone start
    (0  0 20 10  0  0  0) ; half-start
    (0  0  5 20 30 10  0) ; air-start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-blow-probs
  (loop for i in blow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter blow-probs
  (loop for i in xy-blow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter blow-types
  '((tone-air-tone ; ●⟹○⟹●
     tone-air-half ; ●⟹○⟹◐
     tone-half-tone ; ●⟹⌀⟹●
     tone-air ; ●⟹○
     )
    (half-tone-half ; ⌀⟹●⟹⌀
     half-tone-air ; ⌀⟹●⟹○
     half-air-half ; ⌀⟹○⟹⌀
     half-air-tone ; ⌀⟹○⟹●
     )
    (air-tone-air ; ○⟹●⟹○
     air-tone-half ; ○⟹●⟹⌀
     air-half-air ; ○⟹⌀⟹○
     air-tone ; ○⟹●
     )
    -)
  "List of sound articulations.")

(defparameter blow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in blow-probs 
    for k in blow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter blows
(mcflatten
   (loop repeat 4
     initially (init-seed 123)
     collect
  (loop for i in blow-prob-lists
  collect
  (gen-weight 1 i)))))

;;; bows (strings)

(defparameter bow-prob-envs
  '((0 10 10  0  0  0  0) ; tasto start
    (0  0 20 10  0  0  0) ; ord start
    (0  0  5 20 30 10  0) ; pont start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-bow-probs
  (loop for i in bow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the bowing probabilities.")

(defparameter bow-probs
  (loop for i in xy-bow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter bow-types
  '((tasto-ord ; tasto⟹ord
     tasto-pont ; tasto⟹pont
     tasto-ord-tasto ; tasto⟹ord⟹tasto
     tasto-pont-ord ; tasto⟹pont⟹ord
     tasto-pont-tasto ; tasto⟹pont⟹tasto
     )   
    (ord-pont ; ord⟹pont
     ord-tasto ; ord⟹tasto
     ord-tasto-ord ; ord⟹tasto⟹ord
     ord-pont-ord ; ord⟹pont⟹ord
     ord-tasto-pont ; ord⟹tasto⟹pont
     ord-pont-tasto ; ord⟹pont⟹tasto
     )
    (pont-ord ; pont⟹ord
     pont-tasto ; pont⟹tasto
     pont-ord-pont ; "pont⟹ord⟹pont
     pont-tasto-ord ; pont⟹tasto⟹ord
     pont-tasto-pont ; pont⟹tasto⟹pont
     )
    -)
  "List of sound articulations.")

(defparameter bow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in bow-probs 
    for k in bow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter bows
(mcflatten
   (loop repeat 4
     initially (init-seed 579)
     collect
  (loop for i in bow-prob-lists
  collect
  (gen-weight 1 i))))
  "bow articulations")

(defparameter var-tones
  (assign-variable 'tones (append blows bows))
  "combine blow (woods) and bow (strings) atriculations into variables")

(defparameter tones
  (list tones0 tones4 tones1 tones2 tones5 tones6 tones3 tones7)
  "sort tone variables according to the voices: fl vl cl ob vla (vla) tsax vc")

;;; Vibrato

(defparameter vib-prob-envs
  '(( 0 20 30 20 15 10  5) ; vibs
    (30 30 30 30 30 30 30) ; -
    )
  "general developement of weighted probabilities")

(defparameter xy-vib-probs
  (loop for i in vib-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter vib-probs
  (loop for i in xy-vib-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the  envelope xy-vib-probs
             ))))

(defparameter vib-art
  '(non-vib ; non vib    
    nvib-vib-nvib ; non vib⟹vib⟹non vib
    vib-nvib ; vib⟹non vib   
    vib-mvib-nvib ; vib⟹molto vib⟹non vib 
    nvib-vib ; non vib⟹vib
    nvib-mvib-nvib ; non vib⟹molto vib⟹non vib
    vib-nvib-vib ; vib⟹non vib⟹vib
    nvib-mvib-vib ; non vib⟹molto vib⟹vib   
    mvib-nvib-vib ; molto vib⟹non vib⟹vib
    mvib-nvib ; molto vib⟹non vib   
    vib-mvib-vib ; vib⟹molto vib⟹vib
    mvib-vib ; molto vib⟹vib
    nvib-mvib ; non vib⟹molto vib 
    vib-mvib ; vib⟹molto vib
    vib-nvib-mvib ; vib⟹non vib⟹molto vib
    mvib-vib-mvib ; molto vib⟹vib⟹molto vib  
    mvib-nvib-mvib ; molto vib⟹non vib⟹molto vib
    )
  "List of 17 vibrato articulations, sorted from less to more")

(defparameter vib-articulations
  (gen-palindrome vib-art)
  "Palindrome of the vib-articulations, 33 vibratos from less to more to less."
  )

(defparameter vib-ids
  (let* ((len-vib-art (- (length vib-articulations) 1))
         (tend-ids (mapcar #'round 
                           (gen-tendency numb-pitches (list 0.1 len-vib-art) 
                                         :variance 0.5 :seed 123))))
    (loop for i in tend-ids collect (min i len-vib-art)))
  "Tendency of IDs from start to end in the vib-articulations list."
  )

(defparameter vib-art-probs
  (matrix-transpose 
   ; combine probability list of all articulations at each point
  (loop for i in vib-probs
    for x from 0
    collect
    (loop for j in i
      for y from 0
      when (= x 0)
      collect (list (nth (nth y vib-ids) vib-articulations) j)
      ; combine the probabilities with the according articulation
      when (= x 1)
      collect (list '- j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter weighted-vibs
  (loop repeat numb-inst
    initially (init-seed 73)
    collect
    (flatten
     (loop for i in vib-art-probs   
       collect
       (gen-weight 1 i)))))

(defparameter vibratos
(loop for i in weighted-vibs
  collect (position-replace '(0) '(non-vib) i)))

;;; Merge Attributes

(defparameter merged-articulations
  (merge-attributes glissandi tremolos tones vibratos)
  "merge all articulations for each voice")

;; (ll merged-articulations)

(defparameter dummy-articulations
  (cons 'arrow (cdr (loop repeat numb-pitches collect '-)))
  "Make a dummy articulation list for the upper voice of the viola
  with an arrow at the beginning (to be manually DELETED LATER).")

(defparameter articulations
  (list-replace-at merged-articulations 5 (list dummy-articulations))
  "Replace the articulation list of the upper voice of the viola
  with the dummy articulation list.")
 
;;; Voices
    
(defparameter omn
  (make-omn
   :pitch pitches
   :length durations
   :velocity velocities
   :articulation articulations)
  "Create omn voices.")

(defparameter voices (assign-variable 'voice omn)
  "assign variable for each voice")

;;; Score

#!
;; Preview
(ps 'gm
    :multi voices
    :time-signature time-sig
    :tempo 60)
!#

(def-score licht
           (
            :key-signature 'chromatic
            :time-signature time-sig
            :tempo 60
            :layout (list
                     (bracket-group
                      (flute-layout 'fl)
                      (oboe-layout 'ob)
                      (clarinet-layout 'cl)
                      (tenor-sax-layout 'tsax))
                     (bracket-group
                      (glockenspiel-layout 'glsp)
                      (percussion-layout 'perc))
                     (piano-layout 'piano-rh 'piano-lh)
                     (bracket-group
                      (violin-layout 'vn)
                      (viola-solo-layout (list 'va1 'va2))
                      (violoncello-layout 'vc)))
            )
  (fl :omn voice0 :channel 1 :sound 'gm :program 'flute) 
  (ob :omn voice3 :channel 2 :program 'oboe)
  (cl :omn voice2 :channel 3 :program 'clarinet)
  (tsax :omn voice6 :channel 4 :program 'tenor-sax)
  (glsp :omn nil :channel 5 :program 'glockenspiel)
  (perc :omn nil :channel 6 :program 'percussion)
  (piano-rh :omn nil :channel 7 :program 'grand)
  (piano-lh :omn nil :channel 8 :program 'grand)
  (vn :omn voice1 :channel 9 :program 'violin)
  (va1 :omn voice4 :channel 10 ::program 'viola)
  (va2 :omn voice5 :channel 11 ::program 'viola)
  (vc :omn voice7 :channel 12 :program 'cello)
  )