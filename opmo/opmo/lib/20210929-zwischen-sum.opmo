;;; ---------------------------------------------------------
;;; Sicht
;;; Copyright © 2015-2021 Achim Bornhoeft
;;;
;;; zwischen
;;;
;;; ---------------------------------------------------------

(load (merge-pathnames "../lisp/functions.lisp" *load-truename*))

(defparameter *do-verbose* nil
  "Enable or disable traces printed by do-verbose.")

;;; Pitches

(defparameter listed-ratios
(loop for i from 3 to 9
  collect
    (loop 
      for k from (+ i 1) to (+ i (- i 1))     
      collect (/ i k))))

(defparameter sorted-ratios
  (loop for i in listed-ratios
    for x from 1
    if (oddp x)
    collect i 
    else
    collect (reverse i)))

(defparameter ratios 
  (succ-shuffle (flatten sorted-ratios) 30 :seed 123) ; see functions.lisp
  "Flattened list of ratios with some successive values randomly shuffled.")

#|
;; (fl ratios) 

(let ((mcr ratios))
  (list  (* 1.0 (find-min mcr)) (* 1.0 (find-max mcr))))
;; => min/max factors: (3.0 6.0)
  
(loop for i in listed-ratios collect (length i))
;; => increasing length of waves: (7 10 13 16 19 22)
|#

(defparameter diff (pitch-to-hertz 'g5)
  "fixed difference tone")

(defparameter diff-tones
  (loop for i in ratios 
             collect
             ; (sort (comb-fix-tones diff (* diff i) 1 3) '<)))
    (comb-fix-tones diff (* diff i) 1 3)))

;; (chordize (hertz-to-pitch diff-tones))

(defparameter pitches
  (matrix-transpose
   (quarter-tone-closest
    (hertz-to-pitch
     diff-tones
     :quantize 1/4)))
  "Quantize pitches to quartertones and convert chords to voices.") 

(defparameter numb-pitches (length (first pitches))
  "number of pitches per voice")

(defparameter numb-inst (length (first diff-tones))
  "number of instruments (voices)")

;;; Durations

(defparameter parts (sum-to-size numb-pitches 3)
  "Number of events divided in 3 possible equal numbers for 3 parts")

(defparameter counts
  (loop repeat numb-inst
    initially (init-seed 123)
    collect
  (loop for i in parts
    collect
  (rnd-sum i '(2 3 4 5))))
  "4 counts randomly chosen fitting the overall number of events")

;; durations +/- 3/4

;; Count 5
(defparameter dur3-5 
  (dev-durations 3/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur3-4 
 (mapcar #'cdr dur3-5)
  "only the deviations.")

;; Count 3
(defparameter dur3-3-1 
  (dev-durations 3/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur3-3-2 
  (dev-durations 3/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur3-2-1 
  (mapcar #'cdr dur3-3-1)
  "only the deviations")

(defparameter dur3-2-2 
  (mapcar #'cdr dur3-3-2)
  "only the deviations")

;; durations +/- 4/4

;; Count 5
(defparameter dur4-5 
  (dev-durations 4/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur4-4 
 (mapcar #'cdr dur4-5)
  "only the deviations.")

;; Count 3
(defparameter dur4-3-1
  (dev-durations 4/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur4-3-2 
  (dev-durations 4/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur4-2-1 
  (mapcar #'cdr dur4-3-1)
  "only the deviations")

(defparameter dur4-2-2 
  (mapcar #'cdr dur4-3-2)
  "only the deviations")

;; durations +/- 5/4

;; Count 5
(defparameter dur5-5 
  (dev-durations 5/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur5-4 
 (mapcar #'cdr dur5-5)
  "only the deviations.")

;; Count 3
(defparameter dur5-3-1
  (dev-durations 5/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur5-3-2 
  (dev-durations 5/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur5-2-1 
  (mapcar #'cdr dur5-3-1)
  "only the deviations")

(defparameter dur5-2-2 
  (mapcar #'cdr dur5-3-2)
  "only the deviations")

(defparameter dur-lists
  (loop for i in counts
    initially (init-seed 123)
    collect
    (loop for j in i
      for k from 0
      collect
      (rnd-order
       (loop for l in j
         when (= k 0) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur4-2-1 dur4-2-2))))
           (3 (rnd-order (rnd-pick (append dur4-3-1 dur4-3-2))))
           (4 (rnd-order (rnd-pick dur4-4)))
           (5 (rnd-order (rnd-pick dur4-5))))
         when (= k 1) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur3-2-1 dur3-2-2))))
           (3 (rnd-order (rnd-pick (append dur3-3-1 dur3-3-2))))
           (4 (rnd-order (rnd-pick dur3-4)))
           (5 (rnd-order (rnd-pick dur3-5))))
         when (= k 2) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur5-2-1 dur5-2-2))))
           (3 (rnd-order (rnd-pick (append dur5-3-1 dur5-3-2))))
           (4 (rnd-order (rnd-pick dur5-4)))
           (5 (rnd-order (rnd-pick dur5-5)))))))))

#|
(loop for i in dur-lists
  collect (find-sum (flatten i)))
|#

(defparameter durations (quantize (mcflatten dur-lists) '(1 2 3 4 5 6)))

(defparameter time-sig
  (loop for i in parts
    for j in '(4 3 5)
    collect (list j 4 i)))

;;; Dynamics

(defparameter vel-f1
    (flatten
     (loop for j in (first durs)     
       for k from 0 collect
       (if (evenp k)
         (loop repeat (- (length j) 1)
           collect '< into reslis
           finally (return (cons 'pp< reslis)))
         (loop repeat (- (length j) 1)
           collect '> into reslis
           finally (return (cons 'p> reslis )))))))

(defparameter vels
  (loop repeat 7
    initially (init-seed 25)
    collect
    (velocity-to-dynamic
     (gen-weight numb-pitches '((ppp 10) (pp 40)(p 30)(mf 20))))))

(defparameter dummy-vels
  (cons 'ppp (cdr (loop repeat numb-pitches collect '-))))

(defparameter velocities
  (list
   (first vels)
   (second vels)  
   (third vels)
   (fourth vels)
   dummy-vels
   vel-f1
   (sixth vels)
   (seventh vels)))

;;; Articulations
;;; (list of possible articulations see User Attributes.lisp)

;;; Glissandi

(defparameter gliss-prob-env
  ;; (xy-plot
  (pair-up
   (envelope-exp 
    '(0 0 1 0 3 3 5 6 8 10 11 20 13 10 16 0) 
    1.2 (- numb-pitches 1))))
   ;;:join-points t :point-radius 2 :style :axis))

;; (length gliss-prob-env)

(defparameter gliss-prob
  (mapcar #'round
          (second
           (matrix-transpose
            gliss-prob-env)))
  "Extracting and rounding probabilities from env.")
           
(defparameter glissandi
  (mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
     (loop for i in gliss-prob    
       collect
       (gen-weight 1 (list (list 'gliss i) (list '- 10)))))))

;; (ll glissandi)

;;; Tremolos

(defparameter trem-prob-envs
  '((0 10 10  0  0  0  0  0) ; trem-t+trt = 1/32 = 8
    (0  0 20 10  0  0  0  0) ; trem-5e+tr5e = 1/40 = 10
    (0  0  0 30 20 10  0  0) ; trem-3s+tr3s = 1/48 = 12
    (0  0  0 40 30 20 10  0) ; trem-7e+tr7e = 1/56 = 14
    (0  0  0  0 50 30 20 10) ; trem-x+trx = 1/64 = 16
    (100 100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-trem-probs
  (loop for i in trem-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter trem-probs
  (loop for i in xy-trem-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter trem-types
  '(trem-t+trt
    trem-5e+tr5e
    trem-3e+tr3s
    trem-7e+tr7e
    trem-x+trx
    -)
  "List of articulations.")

(defparameter trem-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in trem-probs 
    for k in trem-types
    collect
    (loop for j in i
      collect (list k j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter tremolos
(mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
  (loop for i in trem-prob-lists
  collect
  (gen-weight 1 i)))))

;;(ll tremolos)

;;; blow (woods)

(defparameter blow-prob-envs
  '((0 10 10  0  0  0  0) ; tone start
    (0  0 20 10  0  0  0) ; half-start
    (0  0  5 20 30 10  0) ; air-start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-blow-probs
  (loop for i in blow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter blow-probs
  (loop for i in xy-blow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter blow-types
  '((tone-air-tone ; ●⟹○⟹●
     tone-air-half ; ●⟹○⟹◐
     tone-half-tone ; ●⟹⌀⟹●
     tone-air ; ●⟹○
     )
    (half-tone-half ; ⌀⟹●⟹⌀
     half-tone-air ; ⌀⟹●⟹○
     half-air-half ; ⌀⟹○⟹⌀
     half-air-tone ; ⌀⟹○⟹●
     )
    (air-tone-air ; ○⟹●⟹○
     air-tone-half ; ○⟹●⟹⌀
     air-half-air ; ○⟹⌀⟹○
     air-tone ; ○⟹●
     )
    -)
  "List of sound articulations.")

(defparameter blow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in blow-probs 
    for k in blow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter blows
(mcflatten
   (loop repeat 4
     initially (init-seed 123)
     collect
  (loop for i in blow-prob-lists
  collect
  (gen-weight 1 i)))))

;;; bows (strings)

(defparameter bow-prob-envs
  '((0 10 10  0  0  0  0) ; tasto start
    (0  0 20 10  0  0  0) ; ord start
    (0  0  5 20 30 10  0) ; pont start
    (100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-bow-probs
  (loop for i in bow-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the bowing probabilities.")

(defparameter bow-probs
  (loop for i in xy-bow-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

#|
(defparameter bow-types
  '((tasto-ord ; tasto⟹ord
     tasto-pont ; tasto⟹pont
     tasto-ord-tasto ; tasto⟹ord⟹tasto
     tasto-pont-ord ; tasto⟹pont⟹ord
     tasto-pont-tasto ; tasto⟹pont⟹tasto
     )   
    (ord-pont ; ord⟹pont
     ord-tasto ; ord⟹tasto
     ord-tasto-ord ; ord⟹tasto⟹ord
     ord-pont-ord ; ord⟹pont⟹ord
     ord-tasto-pont ; ord⟹tasto⟹pont
     ord-pont-tasto ; ord⟹pont⟹tasto
     )
    (pont-ord ; pont⟹ord
     pont-tasto ; pont⟹tasto
     pont-ord-pont ; pont⟹ord⟹pont
     pont-tasto-ord ; pont⟹tasto⟹ord
     pont-tasto-pont ; pont⟹tasto⟹pont
     )
    -)
  "List of sound articulations.")
|#

(defparameter bow-types
  '((t-o ; t⟹o
     t-p ; t⟹p
     t-o-t ; t⟹o⟹t
     t-p-o ; t⟹p⟹o
     t-p-t ; t⟹p⟹t
     )   
    (o-p ; o⟹p
     o-t ; o⟹t
     o-t-o ; o⟹t⟹o
     o-p-o ; o⟹p⟹o
     o-t-p ; o⟹t⟹p
     o-p-t ; o⟹p⟹t
     )
    (p-o ; p⟹o
     p-t ; p⟹t
     p-o-p ; p⟹o⟹p
     p-t-o ; p⟹t⟹o
     p-t-p ; p⟹t⟹p
     )
    -)
  "List of sound articulations.")

(defparameter bow-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in bow-probs 
    for k in bow-types
    collect
    (loop for j in i
      for z = (if (listp k) 
                (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                k)
      collect (list z j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter bows
(mcflatten
   (loop repeat 4
     initially (init-seed 579)
     collect
  (loop for i in bow-prob-lists
  collect
  (gen-weight 1 i))))
  "bow articulations")

(defparameter var-tones
  (assign-variable 'tones (append blows bows))
  "combine blow (woods) and bow (strings) atriculations into variables")

(defparameter tones
  (reverse (list tones0 tones1 tones4 tones2 tones3 tones5 tones6 tones7))
  "sort tone variables according to the voices: fl cl vc2 ob tsax va vn (vc1).
  Reversed because the voices are reversed in make-omn!!!")

;;; Vibrato

(defparameter vib-prob-envs
  '(( 0 20 30 20 15 10  5) ; vibs
    (30 30 30 30 30 30 30) ; -
    )
  "general developement of weighted probabilities")

(defparameter xy-vib-probs
  (loop for i in vib-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter vib-probs
  (loop for i in xy-vib-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the envelope xy-vib-probs
             ))))

#|
(defparameter vib-art
  '(non-vib ; non vib    
    nvib-vib-nvib ; non vib⟹vib⟹non vib
    vib-nvib ; vib⟹non vib   
    vib-mvib-nvib ; vib⟹molto vib⟹non vib 
    nvib-vib ; non vib⟹vib
    nvib-mvib-nvib ; non vib⟹molto vib⟹non vib
    vib-nvib-vib ; vib⟹non vib⟹vib
    nvib-mvib-vib ; non vib⟹molto vib⟹vib   
    mvib-nvib-vib ; molto vib⟹non vib⟹vib
    mvib-nvib ; molto vib⟹non vib   
    vib-mvib-vib ; vib⟹molto vib⟹vib
    mvib-vib ; molto vib⟹vib
    nvib-mvib ; non vib⟹molto vib 
    vib-mvib ; vib⟹molto vib
    vib-nvib-mvib ; vib⟹non vib⟹molto vib
    mvib-vib-mvib ; molto vib⟹vib⟹molto vib  
    mvib-nvib-mvib ; molto vib⟹non vib⟹molto vib
    )
  "List of 17 vibrato articulations, sorted from less to more")
|#

(defparameter vib-art
  '(non-vib ; non-vib  
    nv-v-nv ; non vib⟹vib⟹non vib
    v-nv ; v⟹nv 
    v-mv-nv ; v⟹mv⟹nv 
    nv-v ; nv⟹v
    nv-mv-nv ; nv⟹mv⟹nv
    v-nv-v ; v⟹nv⟹v
    nv-mv-v ; nv⟹mv⟹v  
    mv-nv-v ; mv⟹nv⟹v
    mv-nv ; mv⟹nv  
    v-mv-v ; v⟹mv⟹v
    mv-v ; mv⟹v
    nv-mv ; nv⟹mv
    v-mv ; v⟹mv
    v-nv-mv ; v⟹nv⟹mv 
    mv-v-mv ; mv⟹v⟹mv
    mv-nv-mv ; mv⟹nv⟹mv
    )
  "List of 17 vibrato articulations, sorted from less to more")

(defparameter vib-articulations
  (gen-palindrome vib-art)
  "Palindrome of the vib-articulations, 33 vibratos: less ⟹ more ⟹ less."
  )

(defparameter vib-ids
  (let* ((len-vib-art (- (length vib-articulations) 1))
         (tend-ids (mapcar #'round 
                           (gen-tendency numb-pitches (list 0.1 len-vib-art) 
                                         :variance 0.5 :seed 123))))
    (loop for i in tend-ids collect (min i len-vib-art)))
  "Tendency of IDs from start to end in the vib-articulations list."
  )

(defparameter vib-art-probs
  (matrix-transpose 
   ; combine probability list of all articulations at each point
  (loop for i in vib-probs
    for x from 0
    collect
    (loop for j in i
      for y from 0
      when (= x 0)
      collect (list (nth (nth y vib-ids) vib-articulations) j)
      ; combine the probabilities with the according articulation
      when (= x 1)
      collect (list '- j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter weighted-vibs
  (loop repeat numb-inst
    initially (init-seed 73)
    collect
    (flatten
     (loop for i in vib-art-probs   
       collect
       (gen-weight 1 i)))))

(defparameter vibratos
(loop for i in weighted-vibs
  collect (position-replace '(0) '(non-vib) i)))

;;; Merge Attributes

(defparameter merged-articulations
  (merge-attributes glissandi tremolos tones vibratos)
  "merge all articulations for each voice")

;; (ll merged-articulations)

(defparameter dummy-articulations
  (cons 'arrow (cdr (loop repeat numb-pitches collect '-)))
  "Make a dummy articulation list for the upper voice of the viola
  with an arrow at the beginning (to be manually DELETED LATER).")

(defparameter articulations
  (list-replace-at merged-articulations 0 (list dummy-articulations))
  "Replace the articulation list of the upper voice of the violoncello
  with the dummy articulation list.")
 
;;; Voices
    
(defparameter omn
  (reverse
  (make-omn
   :pitch pitches
   :length durations
   :velocity velocities
   :articulation articulations))
  "Create omn voices.")

(defparameter voices (assign-variable 'voice omn)
  "assign variable for each voice")

;;; Score

#!
;; Preview
(ps 'gm
    :multi voices
    :time-signature time-sig
    :tempo 60)
!#

(def-score zwischen
           (
            :key-signature 'chromatic
            :time-signature time-sig
            :tempo 60
            :layout (list
                     (bracket-group
                      (flute-layout 'fl)
                      (oboe-layout 'ob)
                      (clarinet-layout 'cl)
                      (tenor-sax-layout 'tsax))
                     (bracket-group
                      (glockenspiel-layout 'glsp)
                      (percussion-layout 'perc))
                     (piano-layout 'piano-rh 'piano-lh)
                     (bracket-group
                      (violin-solo-layout (list 'vn1 'vn2))
                      (viola-solo-layout 'va)
                      (violoncello-solo-layout 'vc)))
            )
  (fl :omn voice0 :channel 1 :sound 'gm :program 'flute) 
  (ob :omn voice5 :channel 2 :program 'oboe)
  (cl :omn voice4 :channel 3 :program 'clarinet)
  (tsax :omn voice1 :channel 4 :program 'tenor-sax)
  (glsp :omn nil :channel 5 :program 'glockenspiel)
  (perc :omn nil :channel 6 :program 'percussion)
  (piano-rh :omn nil :channel 7 :program 'grand)
  (piano-lh :omn nil :channel 8 :program 'grand)
  (vn1 :omn voice7 :channel 9 :program 'violin)
  (vn2 :omn voice6  :channel 9 :program 'violin)
  (va :omn voice3 :channel 10 ::program 'viola)
  (vc :omn voice2 :channel 12 :program 'cello)
  )

;; (integer-to-pitch (ambitus-instrument 'tenor-sax)) 

#!
(with-open-file 
    (file "~/Documents/projekte/03-kammermusik5-9/AB93-Plain/opmo/xml/zwischen.xml" 
          :direction :output 
          :if-exists :supersede)
  (score-to-musicxml (get-score 'zwischen) file))

(pprint-score 'zwischen)
!#

(print (* 1.0 (get-span (first durs) :sum t)))