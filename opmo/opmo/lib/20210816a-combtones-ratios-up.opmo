;;; ---------------------------------------------------------
;;; Sicht
;;; Copyright Â© 2015-2021 Achim Bornhoeft
;;; ---------------------------------------------------------

;;; FOR JANUSZ TO DEGUG
;;; with all functions and def-attributes included

(defun comb-tones (freq1 freq2 low-order high-order 
                         &key type chords ratios)
  "Combination tones between freq1 and freq2 (Vers 2).
  Info: https://en.wikipedia.org/wiki/Combination_tone"
  
  (labels ((comb-tones (fq1 fq2 low-odr high-odr)
             "combination tones of freq1 with all ratios 
  low to high order."
             (let* ((start (- low-odr 1))
                    (end (- high-odr 1))
                    (sum-tones 
                     (loop for k from start to end
                       append
                       (loop for i from k downto 1
                         for j from 1 to k
                         collect (+ (* i fq1) 
                                    (* j fq2)))))
                    (difference-tones 
                     (loop for k from start to end
                       append
                       (loop for i from k downto 1
                         for j from 1 to k
                         collect (abs (- (* i fq1) 
                                         (* j fq2)))))))
               (list sum-tones difference-tones)))
           (transpose-matrix (list-of-lists)
             "Transpose a matrix represented as a list of lists."
             (apply #'mapcar #'list list-of-lists))
           (flatter (obj)
             "Flatten nested lists."
             (do* ((result (list obj))
                   (node result))
                  ((null node) (delete nil result))
               (cond ((consp (car node))
                      (when (cdar node) (push (cdar node) (cdr node)))
                      (setf (car node) (caar node)))
                     (t (setf node (cdr node)))))))
    (let* ((fq2 (if (listp freq2) freq2 (list freq2)))
           (coto (loop for i in fq2
                   collect
                   (comb-tones freq1 (if ratios (* freq1 i) i) 
                               low-order high-order)))
           (combtone-chords (loop for i in coto collect (flatter i)))
           (combtone-voices (transpose-matrix combtone-chords))
           (coto-trans (transpose-matrix coto))
           (sumtone-chords (first coto-trans))
           (sumtone-voices (transpose-matrix sumtone-chords))
           (difftone-chords (second coto-trans))
           (difftone-voices (transpose-matrix difftone-chords))
           (freqs (loop for i in fq2
                    collect freq1 into res1
                    collect (if ratios (* freq1 i) i) into res2
                    finally (return (list res1 res2))))
           (freq-trans (transpose-matrix freqs))
           (comball-chords (loop for i in combtone-chords
                             for j in freq-trans
                             collect (append j i)))
           (comball-voices (append freqs combtone-voices)))
      (case type
        (combtones (if chords combtone-chords combtone-voices))
        (sumtones (if chords sumtone-chords sumtone-voices))
        (difftones (if chords difftone-chords difftone-voices))
        (otherwise (if chords comball-chords comball-voices))))))

;;; Pitches

;;; TODO: transitions, reduce to 5 min, lower waves,
(defparameter ratios-up 
  (remove nil
          (loop for i from 13 to 24
            ; number of steps depending on limits below
            collect
            (if (oddp i)           
              (loop for j from i to (* 2 i)
                ; odd IDs increasing ratios
                for k = (/ j i)
                when (and (>= k 3/2) (<= k 7/4))
                collect k)
              (loop for j from (* 2 i) downto i
                ; even IDs decreasing ratios
                for k = (/ j i)
                when (and (>= k 3/2) (<= k 7/4))
                collect k)))) 
    "All ratios between 1.25 and 1.75, odd denominator increasing 
  and even denominator decreasing: form with tendencially increasing 
  length of waves: 6 to 19 steps.")

#|
(let ((mcr (flatten ratios-up)))
  (list  (* 1.0 (find-min mcr)) (* 1.0 (find-max mcr))))
;; => min/max ratios

;;; TODO: balance waves with transitions?
(loop for i in ratios-up collect (length i))
;; => tendencially increasing length of waves

(length (flatten ratios-up)) 
;; => number of ratios 
|#

(defparameter freq1 (pitch-to-hertz 'd4))

(defparameter combtones-chords
 (comb-tones freq1 (flatten ratios-up) 2 3 :ratios t :chords t))

;; sort to voices
(defparameter pitches
  (reverse
   (hertz-to-pitch
    (sort
     (matrix-transpose
      (loop for i in combtones-chords
        collect
        (loop for j in i
          when (>= j 17) collect j
          ; neccessary?
          )))
     '< :key 'first) :quantize 1/4)))

;; (pitch-list-plot pitches :join-chords t :join-points t)

;;; Durations
;;; TODO:

(defun dev-durations (ratio quant dev &key (flat t))
  "Calculate a list of quantified deviations from a ratio.

  Args:
  ratio: ratio = measure
  quant: (list of) quantized deviations (divisor of 1)
  dev: deviation from quant, e.g. -1 = -1/16
  flat: default t = results in a flat list

  Examples:
  (dev-durations 3/4 16 '(-1 1))
  (dev-durations 3/4 '(12 16 20) '(-1 1))
  (dev-durations 4/4 '(12 16 20) '(-1 1) :flat nil)"

  (let ((quant-lst (if (numberp quant) (list quant) quant))
        ; force to list if quantisations, divisions of 1 = 4/4
        (dev-lst (if (numberp dev) (list dev) dev)))
    ;deviation list measured by quantisation e.g.  +1 => + 1/16
    (loop for q in quant-lst
      for result = (cons ratio ; add original ratio
                         (loop for i in dev-lst
                           for rq = (* ratio q)
                           collect (* (/ (+ rq i) rq) ratio)))
      if flat appending result ; result as flat list
      else collect result))) ; result with nested lists

(defparameter 3durs 
  (dev-durations 3/4 '(16 20) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations")
(defparameter 4durs 
  (dev-durations 4/4 '(12 16 20) '(-1 1) :flat nil)
  "4/4 duration with 3 deviations")
(defparameter 5durs 
  (dev-durations 5/4 '(10 12 16 20) '(-1 1) :flat nil)
  "5/4 duration with 4 deviations")

(defparameter durall (length (first pitches)) "number of pitches")

(defparameter durs (rnd-sum durall '(9 12 15) :seed 12)
  "sum of 3 durs randomly chosen to fit overall duration.")

(defparameter durations
  (loop repeat (length pitches)
    initially (rnd-seed 17)
    collect
    (loop for i in durs
      when (= i 9)
      appending (rnd-pick (rnd-order 3durs :seed (seed)) 
                          :seed (seed))
      when (= i 12)
      appending (rnd-pick (rnd-order 4durs :seed (seed)) 
                          :seed (seed))
      when (= i 15)
      appending (rnd-pick (rnd-order 5durs :seed (seed)) 
                          :seed (seed))))
  "pick randomly from the shuffled durations according to durs")

(defparameter time-sig
  (get-time-signature
   (mclist
    (loop for i in durs appending
      (loop repeat 3 collect
        (/ (/ i 3) 4)))))
  "time signature from the starting durations 3/4, 4/4 and 5/4")

;;; Dynamics
;;; TODO: 

;;; Articulations
;;; (list of possible articulations see User Attributes.lisp)
;;; TODO: weighted distribution

(add-text-attributes
;; Tremolo speeds
 '(ttr3e "[1/24]")
 '(ttrt "[1/32]")
 '(ttr5e "[1/40]")
 '(ttr3s "[1/48]")
 '(ttr7e "[1/56]")
 '(ttrx "[1/64]"))

(defparameter articulations
  (loop repeat (length pitches)
    with len = (length (first pitches))
    for tremolos = (rnd-sample len '(trem-7e+tr7e - - -))
    for vibratos = (rnd-sample len '(vib non-vib))
    collect (merge-attributes tremolos vibratos)))
 
;;; Voices
    
(defparameter omn
  (make-omn
   :pitch pitches
   :length durations
   :articulation articulations))

;; assign variable for each voice
(setf voices (assign-variable 'voice omn))

;;; Score
#|
(ps 'gm
    :multi voices
    :time-signature time-sig
    :tempo 60)
|#

(def-score ratios-up-1to10
             (
              :key-signature 'chromatic
              :time-signature time-sig
              :tempo 60
              :layout (list
                       (bracket-group
                        (flute-layout 'bfl)
                        (oboe-layout 'ob))
                       (bracket-group
                        (violin-layout* (list 'vn-v1 'vn-v2))
                        (viola-layout* (list 'va-v1 'va-v2))
                        (violoncello-layout* (list 'vc-v1 'vc-v2))))
              :start 1
              :end 10
              )
    
    (bfl :omn voice3 :channel 1 :sound 'gm :program 'flute) 
    (ob :omn voice0 :channel 2 :program 'oboe) 
    (vn-v1 :omn voice1 :channel 3 :program 'violin) 
    (vn-v2 :omn voice2 :channel 3 :program 'violin)
    (va-v1 :omn voice5 :channel 4 :program 'viola) 
    (va-v2 :omn voice4 :channel 4 :program 'viola)
    (vc-v1 :omn voice6 :channel 5 :program 'cello)
    (vc-v2 :omn voice7 :channel 5 :program 'cello)
    )

(defparameter voice
   (make-omn
    :length (list '(-w -q))))

(def-score empty-measure
             (
              :key-signature 'chromatic
              :time-signature '(5 4 1)
              :tempo 60
              :layout (list
                       (bracket-group
                        (flute-layout 'bfl)
                        (oboe-layout 'ob))
                       (bracket-group
                        (violin-layout* (list 'vn-v1 'vn-v2))
                        (viola-layout* (list 'va-v1 'va-v2))
                        (violoncello-layout* (list 'vc-v1 'vc-v2))))
              )
    
    (bfl :omn voice :channel 1 :sound 'gm :program 'flute) 
    (ob :omn voice :channel 2 :program 'oboe) 
    (vn-v1 :omn voice :channel 3 :program 'violin) 
    (vn-v2 :omn voice :channel 3 :program 'violin)
    (va-v1 :omn voice :channel 4 :program 'viola) 
    (va-v2 :omn voice :channel 4 :program 'viola)
    (vc-v1 :omn voice :channel 5 :program 'cello)
    (vc-v2 :omn voice :channel 5 :program 'cello)
    )

(progn
(compile-score '(empty-measure ratios-up empty-measure))
(display-musicxml *last-score*) :display :window)
