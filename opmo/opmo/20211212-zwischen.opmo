;;; ---------------------------------------------------------
;;; Sicht
;;; Copyright © 2015-2021 Achim Bornhoeft
;;;
;;; zwischen
;;;
;;; ---------------------------------------------------------

(load (merge-pathnames "../lisp/functions.lisp" *load-truename*))

(defparameter *do-verbose* nil
  "Enable or disable traces printed by do-verbose.")

;;; Pitches

(defparameter listed-ratios
(loop for i from 2 to 7
  collect
    (loop 
      with x =  (* 3 i)
      for k from x to (* x 2)     
      collect  (* 1.0 (/ k i)))))

(defparameter sorted-ratios
  (loop for i in listed-ratios
    for x from 1
    if (oddp x)
    collect i 
    else
    collect (cdr (butlast (reverse i))))) 

(defparameter ratios 
  (succ-shuffle (flatten sorted-ratios) 40 :seed 123) ; see functions.lisp
  "Flattened list of ratios with some successive values randomly shuffled.")

#|
;; (fl ratios) = 81  

(let ((mcr ratios))
  (list  (* 1.0 (find-min mcr)) (* 1.0 (find-max mcr))))
;; => min/max factors: (3.0 6.0)
  
(loop for i in listed-ratios collect (length i))
;; => increasing length of waves: (7 10 13 16 19 22)
|#

(defparameter diff (pitch-to-hertz 'g2)
  "fixed difference tone")

(defparameter diff-tones
  (loop for i in ratios 
             collect
             (comb-fix-tones diff (* diff i) 1 3)))

(defparameter pitches
  (matrix-transpose
   (quarter-tone-closest
    (hertz-to-pitch
     diff-tones
     :quantize 1/4)))
  "Quantize pitches to quartertones and convert chords to voices.") 

(defparameter numb-pitches (length (first pitches))
  "number of pitches per voice")

(defparameter numb-inst (length (first diff-tones))
  "number of instruments (voices)")

;;; Voices Percussion & Piano

(defparameter difftones-chords-pp
(let* ((combtones (loop for i in ratios 
             collect
             (comb-fix-tones diff (* diff i) 1 5))))
(loop for i in combtones
  collect
  (loop for j in i 
    when (> j 0) collect j))))
       
(defparameter pp-voices
  (make-omn
   :pitch (chordize
           (midi-to-pitch
            (loop for i in
              (pitch-to-midi
               (hertz-to-pitch difftones-chords-pp :quantize 1/4))
              collect
              (remove-duplicates
              (loop for j in i
                when (integerp j)
                collect j)))))
   :length '(w) ; '(q -h.)
   :velocity '(pp)
   :span :pitch))

#|
(defparameter glsp-OLD
  (make-omn
   :pitch
   (respell
    (omn :pitch
         (ambitus-filter '(gs6 c8) pp-voices)))
   :length '(h. w wq) ; '(q -h.)
   :velocity '(pp)
   :span :pitch))
|#

(defparameter glsp
  (let* ((filter-amb (ambitus-filter '(bb6 c8) pp-voices :remain nil))
         (pitches  (respell (omn :pitch filter-amb)))
         (orig-lengths (flatten (omn :length filter-amb)))
         (lengths (gen-repeat 27 '(3/4 4/4 5/4)))
         (new-durs (loop for i in orig-lengths
            for j in lengths
            collect (* i j))))
    (make-omn
     :pitch pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))
#|
(defparameter pno-rh-OLD
(make-omn
   :pitch
   (respell
    (omn :pitch
         (ambitus-filter '(g5 g6) pp-voices)))
   :length '(h. w wq) ; '(q -h.)
   :velocity '(pp)
   :span :pitch))
|#

(defparameter pno-rh
  (let* ((filter-amb (ambitus-filter '(g5 g6) pp-voices :remain nil))
         (pitches  (respell (omn :pitch filter-amb)))
         (orig-lengths (flatten (omn :length filter-amb)))
         (lengths (gen-repeat 27 '(3/4 4/4 5/4)))
         (new-durs (loop for i in orig-lengths
            for j in lengths
            collect (* i j))))
    (make-omn
     :pitch pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

;;; pno-lh-1 see below after time-sig

(defparameter pno-lh-2
  (ambitus-filter '(a0 fs2) pp-voices))

#|
(defparameter vibr-rh-1-OLD
(make-omn
   :pitch
   (respell
    (omn :pitch
         (ambitus-filter '(c5 e5) pp-voices)))
   :length '(wq w h.) ; '(q -h.)
   :velocity '(pp)
   :span :pitch))
|#

(defparameter vibr-rh-1
  (let* ((filter-amb (ambitus-filter '(c5 e5) pp-voices :remain nil))
         (pitches  (respell (omn :pitch filter-amb)))
         (orig-lengths (flatten (omn :length filter-amb)))
         (lengths (gen-repeat 27 '(5/4 4/4 3/4)))
         (new-durs (loop for i in orig-lengths
            for j in lengths
            collect (* i j))))
    (make-omn
     :pitch pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

#|
(defparameter vibr-rh-2-OLD
(make-omn
   :pitch
   (respell
    (omn :pitch
          (ambitus-filter '(gs4 b4) pp-voices)))
   :length '(w h. wq) ; '(q -h.)
   :velocity '(pp)
   :span :pitch))
|#

(defparameter vibr-rh-2
  (let* ((filter-amb (ambitus-filter '(gs4 b4) pp-voices))
         (pitches  (respell (omn :pitch filter-amb)))
         (orig-lengths (flatten (omn :length filter-amb)))
         (lengths (gen-repeat 27 '(4/4 3/4 5/4 )))
         (new-durs (loop for i in orig-lengths
            for j in lengths
            collect (* i j))))
    (make-omn
     :pitch pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

(defparameter vibr-lh-1
  (ambitus-filter '(d4 g4) pp-voices))

(defparameter vibr-lh-2
  (ambitus-filter '(gs3 cs4) pp-voices))

#|
(defparameter timp
  (omn-dictum '((:all trem+gliss))
  (ambitus-filter '(d2 g2) pp-voices)))
|#

(defparameter timp
  (let* ((omn-pitch (omn :pitch      
                         (ambitus-filter '(d2 g2) pp-voices)))
         (omn-len (loop for i in omn-pitch
                    for x from 0
                    collect
                    (if (first i)
                    (list (nth (mod x 3) '(h. w wq)))
                    (list (nth (mod x 3) '(-h. -w -wq)))))))
    (omn-dictum '((:all trem+gliss))
                (make-omn 
                 :pitch (remove nil omn-pitch)
                 :length omn-len
                 :velocity '(pp)
                 :span :length))                   
    ))

;;; Durations

(defparameter parts (sum-to-size numb-pitches 3)
  "Number of events divided in 3 possible equal numbers for 3 parts")

(defparameter counts
  (loop repeat numb-inst
    initially (init-seed 123)
    collect
  (loop for i in parts
    collect
  (rnd-sum i '(2 3 4 5))))
  "4 counts randomly chosen fitting the overall number of events")

;; durations +/- 3/4

;; Count 5
(defparameter dur3-5 
  (dev-durations 3/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur3-4 
 (mapcar #'cdr dur3-5)
  "only the deviations.")

;; Count 3
(defparameter dur3-3-1 
  (dev-durations 3/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur3-3-2 
  (dev-durations 3/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur3-2-1 
  (mapcar #'cdr dur3-3-1)
  "only the deviations")

(defparameter dur3-2-2 
  (mapcar #'cdr dur3-3-2)
  "only the deviations")

;; durations +/- 4/4

;; Count 5
(defparameter dur4-5 
  (dev-durations 4/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur4-4 
 (mapcar #'cdr dur4-5)
  "only the deviations.")

;; Count 3
(defparameter dur4-3-1
  (dev-durations 4/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur4-3-2 
  (dev-durations 4/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur4-2-1 
  (mapcar #'cdr dur4-3-1)
  "only the deviations")

(defparameter dur4-2-2 
  (mapcar #'cdr dur4-3-2)
  "only the deviations")

;; durations +/- 5/4

;; Count 5
(defparameter dur5-5 
  (dev-durations 5/4 '(16 20 24) '(-2 -1 1 2) :flat nil)
  "duration with 4 deviations, (see functions.lisp)")

;; Count 4
(defparameter dur5-4 
 (mapcar #'cdr dur5-5)
  "only the deviations.")

;; Count 3
(defparameter dur5-3-1
  (dev-durations 5/4 '(16 20 24) '(-1 1) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

(defparameter dur5-3-2 
  (dev-durations 5/4 '(16 20 24) '(-2 2) :flat nil)
  "3/4 duration with 2 deviations, (see functions.lisp)")

;; Count 2
(defparameter dur5-2-1 
  (mapcar #'cdr dur5-3-1)
  "only the deviations")

(defparameter dur5-2-2 
  (mapcar #'cdr dur5-3-2)
  "only the deviations")

(defparameter dur-lists
  (loop for i in counts
    initially (init-seed 123)
    collect
    (loop for j in i
      for k from 0
      collect
      (rnd-order
       (loop for l in j
         when (= k 0) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur4-2-1 dur4-2-2))))
           (3 (rnd-order (rnd-pick (append dur4-3-1 dur4-3-2))))
           (4 (rnd-order (rnd-pick dur4-4)))
           (5 (rnd-order (rnd-pick dur4-5))))
         when (= k 1) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur3-2-1 dur3-2-2))))
           (3 (rnd-order (rnd-pick (append dur3-3-1 dur3-3-2))))
           (4 (rnd-order (rnd-pick dur3-4)))
           (5 (rnd-order (rnd-pick dur3-5))))
         when (= k 2) collect
         (case l
           (2 (rnd-order (rnd-pick (append dur5-2-1 dur5-2-2))))
           (3 (rnd-order (rnd-pick (append dur5-3-1 dur5-3-2))))
           (4 (rnd-order (rnd-pick dur5-4)))
           (5 (rnd-order (rnd-pick dur5-5)))))))))

#|
(loop for i in dur-lists
  collect (find-sum (flatten i)))
|#

(defparameter durations (quantize (mcflatten dur-lists) '(1 2 3 4 5 6)))

(defparameter time-sig
  (loop for i in parts
    for j in '(4 3 5)
    collect (list j 4 i)))

;;; Additional Piano layers

(defparameter time-sig-durs
  (mclist
  (flatten (loop for i in 
             (time-signature-length time-sig)
             with one-third = (/ numb-pitches 3)
             collect
             (loop repeat one-third
               collect (/ i one-third))))))


(defparameter pno-lh-1
  (make-omn
   :pitch
   (respell
    (omn :pitch
         (ambitus-filter '(g2 g3) pp-voices)))
   :length time-sig-durs
   :velocity '(pp)
   :span :pitch)
  "durations from time-sig")


(defparameter pno-rh2-1
  (let* ((pno-pitches (rnd-order 
                       (melodize 
                        (omn :pitch pno-lh-1)) :seed 123))
         (new-durs
          (loop for i in pno-pitches
            for j in time-sig-durs
            collect
            (loop repeat (length i)
              collect (/ (first j) (length i))))))
    (make-omn
     :pitch pno-pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

(defparameter pno-rh2-2
  (let* ((pno-pitches (rnd-order 
                       (melodize 
                        (omn :pitch pno-lh-2)) :seed 123))
         (new-durs
          (loop for i in pno-pitches
            for j in time-sig-durs
            if i
            collect
            (loop repeat (length i)
              collect (/ (first j) (length i)))
              else
              collect (list (* -1 (first j))))))
    (make-omn
     :pitch pno-pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

#|
(defparameter pno-all-pitches
  (let* ((all-pitches 
          (rnd-order
           (ambitus-filter '(a0 a7) 
                           (melodize 
                            (omn :pitch 
                                 (mapcar #'sort-asc pp-voices))))
           :seed 123))
         (new-durs
          (loop for i in all-pitches
            for j in time-sig-durs
            collect
            (loop repeat (length i)
              collect (/ (first j) (length i))))))
    (make-omn
     :pitch  all-pitches
     :length (quantize
              new-durs 
              (gen-integer 1 16))
     :velocity '(pp)
     :span :length)
    ))
|#

(defparameter pno-all-pitches
  (let* ((all-pitches
          (rnd-order
           (ambitus-filter '(a0 a7) 
                           (melodize 
                            (omn :pitch (mapcar #'sort-asc pp-voices))))
           :seed 123))
         (new-numb
          (loop for i in time-sig-durs
            for j in all-pitches
            for k = (* 4 (first i))
            for l = (* k 
                       (floor 
                        (/ (length j) k)))
            collect (if (zerop l) k l)))
         (new-durs
          (loop for i in new-numb
            for j in time-sig-durs
            collect
            (loop repeat i
              collect (/ (first j) i))))
         (new-pitches
          (loop for i in all-pitches
            for j in new-numb
            collect (rnd-unique j i))))
    ;(length-legato
    (ambitus-filter '(a0 a7)
                    (make-omn
                     :pitch  new-pitches
                     :length new-durs   
                     :velocity '(pp)
                     :span :length)
                    )))

(defparameter pno-all-rh (ambitus-filter '(c4 a7) pno-all-pitches))

(defparameter pno-all-lh (ambitus-filter '(a0 b3) pno-all-pitches))


(defparameter vibr-all
  (let* ((all-pitches
          (omn  :pitch
                (ambitus-filter (integer-to-pitch 
                                 (ambitus-instrument 'vibraphone)) 
                                pno-all-pitches)))
         (new-durs
          (loop for i in all-pitches
            for j in time-sig-durs
            if i
            collect
            (loop repeat (length i)
              collect (/ (first j) (length i)))
              else
              collect (list (* -1 (first j))))))
    (make-omn
     :pitch all-pitches
     :length new-durs
     :velocity '(pp)
     :span :length)))

;;; Dynamics

(defparameter vels
  (loop repeat 8
    initially (init-seed 25)
    collect
    (velocity-to-dynamic
     (gen-weight numb-pitches '((ppp 20) (pp 20)(p 20)(mf 20) (f 20))))))


(defparameter dummy-vels
  (cons 'ppp (cdr (loop repeat numb-pitches collect '-))))

(defparameter velocities
  (list
   dummy-vels
   (first vels)      
   (second vels) 
   (third vels)
   (fourth vels)
   (fifth vels)
   (sixth vels)
   (seventh vels)
   ))

;;; Articulations
;;; (list of possible articulations see User Attributes.lisp)

;;; Glissandi

(defparameter gliss-prob-env
  (pair-up
   (envelope-exp
    (flatten
    (matrix-transpose
     (list (gen-integer 10)
           (reverse '(0 10 20 30 50 80 50 30 20 10 0)))))
    1.2 (- numb-pitches 1))))

;; (length gliss-prob-env)

(defparameter gliss-prob
  (mapcar #'round
          (second
           (matrix-transpose
            gliss-prob-env)))
  "Extracting and rounding probabilities from env.")
           
(defparameter glissandi
  (mcflatten
   (loop repeat numb-inst
     initially (init-seed 2)
     collect
     (loop for i in gliss-prob    
       collect
       (gen-weight 1 (list (list 'gliss i) (list '- 50)))))))

;; (ll glissandi)

;; Test
#!
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length glissandi)
                     (list (gen-repeat (length (first glissandi)) 'w)))
            :pitch '((b4))
            :articulation glissandi)
    :time-signature '(4 4))
!#

;;; Tremolos

(progn
(defparameter trem-prob-envs
  '((  1   3   5   8   8   5   3   2   1   0   0) ; trem-t+trt = 1/32 = 8
    (  0   2   3   5  13   8   5   3   2   1   0) ; trem-5e+tr5e = 1/40 = 10
    (  0   1   2   3   8  21  13   8   5   3   2) ; trem-3s+tr3s = 1/48 = 12
    (  0   0   1   2   8  13  34  21  13   8   5) ; trem-7e+tr7e = 1/56 = 14
    (100 100 100 100 100 100 100 100 100 100 100) ; -
    )
  "developement of probabilities")

(defparameter xy-trem-probs
  (loop for i in trem-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter trem-probs
  (loop for i in xy-trem-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the initial envelope xy-probs
             ))))

(defparameter trem-types
  '(trem-t+trt
    trem-5e+tr5e
    trem-3e+tr3s
    trem-7e+tr7e
    -)
  "List of articulations.")

(defparameter trem-prob-lists
  (matrix-transpose ; combine probability list of all articulations at each point
  (loop for i in trem-probs 
    for k in trem-types
    collect
    (loop for j in i
      collect (list k j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter tremolos
(mcflatten
   (loop repeat numb-inst
     initially (init-seed 2) ; 2
     collect
  (loop for i in trem-prob-lists
  collect
  (gen-weight 1 i)))))
)
;;(ll tremolos)

;; Test
#!
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length tremolos)
                     (list (gen-repeat (length (first tremolos)) 'w)))
            :pitch '((b4))
            :articulation tremolos)
    :time-signature '(4 4))
!#

;;; blow (woods)

(progn
  (defparameter blow-prob-envs
    '(( 0  34  21  13   8   3   5   8  13  21  0) ; tone start
      ( 0   2   3   5   8  13   8   5   3   2  0) ; half-start
      ( 0  21  13   8   5   3   8  13  21  34  0) ; air-start
      (50  50  50  50  50  50  50  50  50  50 50) ; ord
      )
    "developement of probabilities")
  
  (defparameter xy-blow-probs
    (loop for i in blow-prob-envs
      collect
      (loop for j in i
        for k from 0
        collect k
        collect j))
    "Add x-values to the probabilities.")
  
  (defparameter blow-probs
    (loop for i in xy-blow-probs
      collect
      (mapcar #'round ;  round for weighted random
              (second ; select only the y-values
               (envelope-sample i numb-pitches :type :x-y) 
               ; taking n samples from the initial envelope xy-probs
               ))))
  
  (defparameter blow-types
    '((tone-air-tone ; ●⟹○⟹●
       tone-air-half ; ●⟹○⟹◐
       tone-half-tone ; ●⟹⌀⟹●
       tone-air ; ●⟹○
       )
      (half-tone-half ; ⌀⟹●⟹⌀
       half-tone-air ; ⌀⟹●⟹○
       half-air-half ; ⌀⟹○⟹⌀
       half-air-tone ; ⌀⟹○⟹●
       )
      (air-tone-air ; ○⟹●⟹○
       air-tone-half ; ○⟹●⟹⌀
       air-half-air ; ○⟹⌀⟹○
       air-tone ; ○⟹●
       )
      -)
    "List of sound articulations.")
  
  (defparameter blow-prob-lists
    (matrix-transpose ; combine probability list of all articulations at each point
     (loop for i in blow-probs 
       for k in blow-types
       collect
       (loop for j in i
         for z = (if (listp k) 
                   (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                   k)
         collect (list z j))))
    "Combine probabilities and articulations for gen-weight.")
  
  (defparameter blows
    (mcflatten
     (loop repeat 4
       initially (init-seed 123)
       collect
       (loop for i in blow-prob-lists
         collect
         (gen-weight 1 i)))))
  
  ;;; bows (strings)
  
  (defparameter bow-prob-envs
    '(( 0  34  21  13   8   3   5   8  13  21  0) ; tasto start
      ( 0   2   3   5   8  13   8   5   3   2  0) ; ord start
      ( 0  21  13   8   5   3   8  13  21  34  0) ; pont start
      (50  50  50  50  50  50  50  50  50  50 50) ; -
      )
    "developement of probabilities")
  
  (defparameter xy-bow-probs
    (loop for i in bow-prob-envs
      collect
      (loop for j in i
        for k from 0
        collect k
        collect j))
    "Add x-values to the bowing probabilities.")
  
  (defparameter bow-probs
    (loop for i in xy-bow-probs
      collect
      (mapcar #'round ;  round for weighted random
              (second ; select only the y-values
               (envelope-sample i numb-pitches :type :x-y) 
               ; taking n samples from the initial envelope xy-probs
               ))))
  
  (defparameter bow-types
    '((t-o ; t⟹o
       t-p ; t⟹p
       t-o-t ; t⟹o⟹t
       t-p-o ; t⟹p⟹o
       t-p-t ; t⟹p⟹t
       )   
      (o-p ; o⟹p
       o-t ; o⟹t
       o-t-o ; o⟹t⟹o
       o-p-o ; o⟹p⟹o
       o-t-p ; o⟹t⟹p
       o-p-t ; o⟹p⟹t
       )
      (p-o ; p⟹o
       p-t ; p⟹t
       p-o-p ; p⟹o⟹p
       p-t-o ; p⟹t⟹o
       p-t-p ; p⟹t⟹p
       )
      -)
    "List of sound articulations.")
  
  (defparameter bow-prob-lists
    (matrix-transpose ; combine probability list of all articulations at each point
     (loop for i in bow-probs 
       for k in bow-types
       collect
       (loop for j in i
         for z = (if (listp k) 
                   (nth (rnd1 :low 0 :high (- (length k) 1)) k)
                   k)
         collect (list z j))))
    "Combine probabilities and articulations for gen-weight.")
  
  (defparameter bows
    (mcflatten
     (loop repeat 4
       initially (init-seed 579)
       collect
       (loop for i in bow-prob-lists
         collect
         (gen-weight 1 i))))
    "bow articulations")
  
  (defparameter var-tones
    (assign-variable 'tones (append blows bows))
    "combine blow (woods) and bow (strings) atriculations into variables")
  
  (defparameter tones
    (reverse (list tones0 tones1 tones4 tones2 tones3 tones5 tones6 tones7))
    "sort tone variables according to the voices: fl cl vc2 ob tsax va vn (vc1).
    Reversed because the voices are reversed in make-omn!!!")
  )

;; Test
#!
(ps 'gm    
    :multi
    (make-omn
     :length (gen-repeat
              (length var-tones)
              (list (gen-repeat (length (eval (first var-tones))) 'w)))
     :pitch '((b4))
     :articulation (mapcar #'eval var-tones))
    :time-signature '(4 4))
!#

;;; Vibrato

(progn
(defparameter vib-prob-envs
  '(( 3  8 21 54 34 21 08 13 05 03 02) ; vibs
    (50 50 50 50 50 50 50 50 50 50 50) ; -
    )
  "general developement of weighted probabilities")

(defparameter xy-vib-probs
  (loop for i in vib-prob-envs
    collect
    (loop for j in i
      for k from 0
      collect k
      collect j))
  "Add x-values to the probabilities.")

(defparameter vib-probs
  (loop for i in xy-vib-probs
    collect
    (mapcar #'round ;  round for weighted random
            (second ; select only the y-values
             (envelope-sample i numb-pitches :type :x-y) 
             ; taking n samples from the envelope xy-vib-probs
             ))))

(defparameter vib-art
  '(non-vib ; non-vib  
    nv-v-nv ; non vib⟹vib⟹non vib
    v-nv ; v⟹nv 
    v-mv-nv ; v⟹mv⟹nv 
    nv-v ; nv⟹v
    nv-mv-nv ; nv⟹mv⟹nv
    v-nv-v ; v⟹nv⟹v
    nv-mv-v ; nv⟹mv⟹v  
    mv-nv-v ; mv⟹nv⟹v
    mv-nv ; mv⟹nv  
    v-mv-v ; v⟹mv⟹v
    mv-v ; mv⟹v
    nv-mv ; nv⟹mv
    v-mv ; v⟹mv
    v-nv-mv ; v⟹nv⟹mv 
    mv-v-mv ; mv⟹v⟹mv
    mv-nv-mv ; mv⟹nv⟹mv
    )
  "List of 17 vibrato articulations, sorted from less to more")

(defparameter vib-articulations
  (gen-palindrome vib-art)
  "Palindrome of the vib-articulations, 33 vibratos: less ⟹ more ⟹ less."
  )

(defparameter vib-ids
  (let* ((len-vib-art (- (length vib-articulations) 1))
         (tend-ids (mapcar #'round 
                           (gen-tendency numb-pitches (list 0.1 len-vib-art) 
                                         :variance 0.5 :seed 73))))
    (loop for i in tend-ids collect (min i len-vib-art)))
  "Tendency of IDs from start to end in the vib-articulations list."
  )

(defparameter vib-art-probs
  (matrix-transpose 
   ; combine probability list of all articulations at each point
  (loop for i in vib-probs
    for x from 0
    collect
    (loop for j in i
      for y from 0
      when (= x 0)
      collect (list (nth (nth y vib-ids) vib-articulations) j)
      ; combine the probabilities with the according articulation
      when (= x 1)
      collect (list '- j))))
  "Combine probabilities and articulations for gen-weight.")

(defparameter weighted-vibs
  (loop repeat numb-inst
    initially (init-seed 73)
    collect
    (flatten
     (loop for i in vib-art-probs   
       collect
       (gen-weight 1 i)))))

(defparameter vibratos
(loop for i in weighted-vibs
  collect (position-replace '(0) '(non-vib) i)))
)

#!
;; Test
(ps 'gm
    :multi (make-omn
            :length (gen-repeat
                     (length vibratos)
                     (list (gen-repeat (length (first vibratos)) 'w)))
            :pitch '((b4))
            :articulation vibratos)
    :time-signature '(4 4))
!#

;;; Merge Attributes

(defparameter merged-articulations
  (merge-attributes glissandi tremolos tones vibratos)
  "merge all articulations for each voice")

;; (ll merged-articulations)

(defparameter dummy-articulations
  (cons 'arrow (cdr (loop repeat numb-pitches collect '-)))
  "Make a dummy articulation list for the upper voice of the viola
  with an arrow at the beginning (to be manually DELETED LATER).")

(defparameter articulations
  (list-replace-at merged-articulations 0 (list dummy-articulations))
  "Replace the articulation list of the upper voice of the violoncello
  with the dummy articulation list.")
 
;;; Voices
    
(defparameter omn
  (reverse
  (make-omn
   :pitch pitches
   :length durations
   :velocity velocities
   :articulation articulations))
  "Create omn voices.")

(defparameter voices (assign-variable 'voice omn)
  "assign variable for each voice")

;;; Score

#!
;; Preview
(ps 'gm
    :multi voices
    :time-signature time-sig
    :tempo 60)
!#

(def-score zwischen
           (
            :key-signature 'chromatic
            :time-signature time-sig
            :tempo 60
            :layout (list
                     (bracket-group
                      (flute-layout 'fl)
                      (oboe-layout 'ob)
                      (clarinet-layout 'cl)
                      (tenor-sax-layout 'tsax))
                     (bracket-group
                      (glockenspiel-layout 'glsp)
                      (bracket-group
                       (vibraphone-single-layout 
                        (list 'vibra-rh-1 'vibra-rh-2))
                       (vibraphone-single-layout 
                        (list 'vibra-lh-1 'vibra-lh-2))
                       (vibraphone-single-layout 
                        'vibra-all))
                      (timpani-layout 'timp))
                     (bracket-group
                      (piano-layout 'piano-rh (list 'piano-rh2-1 'piano-rh2-2))
                      (piano-layout 'pno-all-rh 'pno-all-lh)
                      (piano-layout 'piano-lh-1 'piano-lh-2))
                      (bracket-group
                      (violin-layout 'vn)
                      (viola-solo-layout 'va)
                      (violoncello-solo-layout (list 'vc1 'vc2))))          
            )

  (fl :omn voice0 :channel 1 :sound 'gm :program 'flute) 
  (ob :omn voice3 :channel 2 :program 'oboe)
  (cl :omn voice1 :channel 3 :program 'clarinet)
  (tsax :omn voice4 :channel 4 :program 'tenor-sax)
  (glsp :omn glsp :channel 5 :program 'glockenspiel)
  (vibra-rh-1 :omn vibr-rh-1 :channel 6 :program 'vibraphone)
  (vibra-rh-2 :omn vibr-rh-2 :channel 6 :program 'vibraphone)
  (vibra-lh-1 :omn vibr-lh-1 :channel 7 :program 'vibraphone)
  (vibra-lh-2 :omn vibr-lh-2 :channel 7 :program 'vibraphone)
  (vibra-all :omn vibr-all :channel 7 :program 'vibraphone) 
  (timp :omn timp :channel 8 :program 'timpani)
  (piano-rh :omn pno-rh :channel 9 :program 'grand)
  (piano-rh2-1 :omn pno-rh2-1 :channel 10 :program 'grand)
  (piano-rh2-2 :omn pno-rh2-2 :channel 10 :program 'grand)
  (pno-all-rh :omn pno-all-rh :channel 10 :program 'grand)
  (pno-all-lh :omn pno-all-lh :channel 10 :program 'grand)
  (piano-lh-1 :omn pno-lh-1 :channel 10 :program 'grand)
  (piano-lh-2 :omn pno-lh-2 :channel 10 :program 'grand)  
  (vn :omn voice6 :channel 11 :program 'violin)
  (va :omn voice5 :channel 12 ::program 'viola)
  (vc1 :omn voice7 :channel 13 ::program 'cello)
  (vc2 :omn voice2 :channel 14 :program 'cello)
  )

;;; Calculate overall duration
(let* ((dursec (* 4.0
                  (get-span (first dur-lists) :sum t)))
       (minutes (floor (/ dursec 60)))
       (seconds (- dursec (* minutes 60))))                
  (format t "Duration: ~F min ~F sec " minutes seconds))

#!
(with-open-file 
    (file "~/Documents/projekte/03-kammermusik5-9/AB93-Plain/opmo/xml/zwischen.xml" 
          :direction :output 
          :if-exists :supersede)
  (score-to-musicxml (get-score 'zwischen) file))

(pprint-score 'zwischen)
!#